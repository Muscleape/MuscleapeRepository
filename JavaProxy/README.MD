# Java代理内容整理

## 1、JDK静态代理

 1. 业务接口
 2. 接口的实现类
 3. 代理类，实现接口，并扩展实现类的功能

 > 原理

 一般是代理类对象直接包装被代理对象

 > 缺点

 只能为一个被代理类服务，如果需要代理多个类，会产生过多的代理类；

> 优点

 在编译时产生class文件，运行时无需产生，可以直接使用，效率好；

## 2、JDK动态代理

1. 业务接口
2. 实现了业务接口的业务类
3. 实现了InvocationHandler接口的handler代理类

> 原理

1. 是接口代理；
2. 被代理类需要实现业务接口；
3. 业务代理类需要实现InvocationHandler接口；
4. **JDK动态代理会根据被代理对象生成一个继承Proxy类，并实现该业务接口的JDK代理类，该类的字节码会被传进去的ClassLoader加载，创建JDK代理对象实例**；
5. JDK代理对象实例创建
    1. 创建业务代理对象实例；
    2. 1中的实例赋值给Proxy类；
    3. 通过2，JDK代理对象实例也就有了业务代理对象实例；
    4. JDK代理对象实例通过反射，根据被代理类的业务方法创建相应的Method对象（**可能有多个**）；
    5. JDK代理对象实例调用业务方法时，会先把Method对象作为参数传递给invoke()方法（invoke方法的第二个参数）；
    6. 调用JDK代理对象实例的invoke()回调方法，在invoke方法里通过反射来调用代理对象的方法；

> 缺点

必须实现接口；通过反射动态代理方法，消耗系统性能；

> 优点

无需产生过多的代理类，避免重复代码，系统更加灵活；

## 3、CGLIB动态代理

> 不需要定义业务接口

1. 业务类（不需要实现接口）
2. cglib代理类（实现接口MethodInterceptor）

> 原理

1. 是继承代理；
2. 因为是继承，所有类和方法都不能用final修饰符；

> 缺点

1. CGLIB会继承被代理类；
2. CGLIB会重写被代理方法；
3. 代理类和代理方法不能使用final修饰符；

> 优点

1. 无需实现接口，通过子类字节码来实现；
2. 比反射速度快，没有性能问题；

## 4、JDK动态代理和CGLIB动态代理

JDK|CGLIB
---|-----
只能代理实现了接口的类；没有实现接口的类不能实现JDK动态代理|针对类来实现代理；对指定目标类产生一个子类，通过**方法拦截技术**拦截所有父类方法的调用

## 5、代理总结

>代理可以看做是对调用目标的一个包装，对目标代码的调用不是直接发生的，而是通过代理完成。
>
>代理可以让调用者与实现者之家解耦，比如RPC调用，框架内部的寻址、序列化、反序列化等。